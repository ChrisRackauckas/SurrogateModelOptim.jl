var documenterSearchIndex = {"docs":
[{"location":"#SurrogateModelOptim.jl-1","page":"Home","title":"SurrogateModelOptim.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"SurrogateModelOptim is a Julia package for the optimisation of expensive functions.  The surrogate model is based on an ensemble of Radial Basis Function interpolants with adaptive axis scaling.","category":"page"},{"location":"smoptimize/#Surrogate-model-optimization-1","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"","category":"section"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"A julia function can be optimised with","category":"page"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"smoptimize","category":"page"},{"location":"smoptimize/#SurrogateModelOptim.smoptimize","page":"Surrogate model optimization","title":"SurrogateModelOptim.smoptimize","text":"smoptimize(f::Function, search_range::Array{Tuple{Float64,Float64},1}; options=Options())\n\nOptimize the function f in the range search_range using a Radial Basis Function based surrogate model.\n\n\n\n\n\n","category":"function"},{"location":"smoptimize/#Example-1","page":"Surrogate model optimization","title":"Example","text":"","category":"section"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"julia> using SurrogateModelOptim\njulia> rosenbrock_2D(x) = (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2\njulia> search_range=[(-5.0,5.0),(-5.0,5.0)]\njulia> smoptimize(rosenbrock_2D, search_range)","category":"page"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"Due to the high cost of creating several surrogates it is highly advisable to create the surrogate model in parallel. Start julia in parallel with > julia -p x where x is the number of available cores. The previous example can then be run as","category":"page"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"julia> result = smoptimize(rosenbrock_2D, search_range;\n                    options=SurrogateModelOptim.Options(\n                    iterations=25,\n                    num_interpolants=N*x, #Where N is an integer number\n                    num_start_samples=5,\n                        ));","category":"page"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"The default option num_interpolants=20 meaning the surrogate model ensemble contains 20 RBF interpolants has shown good performance for a variety of functions. More test functions and examples can be found in the source files under examples. The performance is typically good for smooth functions with or without noise.  Discontinuous functions are not captured well by RBF interpolation, see  the example folder to see this problem.","category":"page"},{"location":"surrogate_model/#Surrogate-model-1","page":"Surrogate model","title":"Surrogate model","text":"","category":"section"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"The surrogate model which is used for the optimisation can be created manually with","category":"page"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"surrogate_model","category":"page"},{"location":"surrogate_model/#SurrogateModelOptim.surrogate_model","page":"Surrogate model","title":"SurrogateModelOptim.surrogate_model","text":"surrogate_model(plan::AbstractArray{T,2}, samples::AbstractArray{T,2}; options=Options()) where T\n\nReturns a surrogate model function based on an optimized Radial Basis Function interpolant. Depending on the options, the kernel, kernel width and scaling of  input data is optimized.\n\n...\n\nArguments\n\nplan::AbstractArray{T,2}:    sample locations where each column corresponds to the location of one point.   size(plan) = (num_dimensions,num_samples).\nsamples::AbstractArray{T,2}:   function value at each sample location. each column contains one value from   the corresponding plan location. size(samples) = (1,num_samples).\noptions=Options():    all options available to customize the surrogate optimization.  \n\n...\n\n\n\n\n\n","category":"function"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"This enables the freedom to chose how it is optimised and used. When called, the  function value from each surrogate in the ensemble is returned.","category":"page"},{"location":"surrogate_model/#Example-1","page":"Surrogate model","title":"Example","text":"","category":"section"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"julia> rosenbrock_2D(x) = (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2\njulia> search_range=[(-5.0,5.0),(-5.0,5.0)]\n\n# Start from 5 Latin Hypercube Samples\njulia> num_samples=5\njulia> sampling_plan_opt_gens=10_000\njulia> plan = scaled_LHC_sampling_plan(search_range,num_samples,sampling_plan_opt_gens;trace=false)\n\n# Evaluate the function \njulia> samples = mapslices(rosenbrock_2D,plan,dims=1)\n\n# Create the optimized surrogate model (optres contains the optimisation results for the surrogate)\nopt=SurrogateModelOptim.Options()\njulia> sm_interpolant, optres = surrogate_model(plan, samples;options=opt)","category":"page"},{"location":"surrogate_model/#Model-infill-1","page":"Surrogate model","title":"Model infill","text":"","category":"section"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"New design locations can be found with","category":"page"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"model_infill","category":"page"},{"location":"surrogate_model/#SurrogateModelOptim.model_infill","page":"Surrogate model","title":"SurrogateModelOptim.model_infill","text":"model_infill(search_range::Vector{Tuple{Float64,Float64}},plan::AbstractArray{T,2},\nsamples::AbstractArray{T,2},sm_interpolant; options::Options=Options()) where T\n\nInfill function that takes calculates the location of new samples based  on the supplied options. The returned options are updated updated to facilitate cycling through the infill objective functions.\n\n...\n\nArguments\n\nsearch_range::Vector{Tuple{Float64,Float64}:   a vector of tuples containing the lower and upper limits   for each dimension. length(search_range) is equal to number   of dimensions.\nplan::AbstractArray{T,2}:    sample locations where each column corresponds to the location of one point.   size(plan) = (num_dimensions,num_samples).\nsamples::AbstractArray{T,2}:   function value at each sample location. each column contains one value from   the corresponding plan location. size(samples) = (1,num_samples).\noptions=Options():    all options available to customize the surrogate infill.  \n\n...\n\n\n\n\n\n","category":"function"},{"location":"surrogate_model/#Example-2","page":"Surrogate model","title":"Example","text":"","category":"section"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"julia> infill_plan, infill_type, infill_prediction, options = model_infill(search_range,plan,samples,sm_interpolant; options=Options())","category":"page"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"note: Note\nThe options are updated to cycle through the infill_type.","category":"page"},{"location":"options/#Options-1","page":"Options","title":"Options","text":"","category":"section"},{"location":"options/#","page":"Options","title":"Options","text":"The available options are listed below. The performance using the default options has been good for several test functions, with and without noise. Make sure to set num_interpolants to a value which is a multiple of the number of processes used for the least amount of time to create the surrogate. ","category":"page"},{"location":"options/#","page":"Options","title":"Options","text":"num_start_samples::Int = 5                              # Samples included in the LHC sampling plan\ntrace::Bool = true                                      # Print progress\nsampling_plan_opt_gens::Int = 5000                      # Iterations used to optimize the LHC sampling plan\nrippa::Bool = true                                      # Rippas algorithm to reduce computational effort optimising the surrogate\nkerns = [ScatteredInterpolation.Gaussian,               # RBF kernels to choose from\n        ScatteredInterpolation.InverseQuadratic,        \n        ScatteredInterpolation.InverseMultiquadratic]\nrbf_opt_gens::Int = 50_000                              # Generations that the RBF hyperparameters are optimized\nrbf_opt_pop::Int = 50                                   # Population size of RBF hyperparameter optimization\nrbf_opt_method::Symbol = :de_rand_1_bin_radiuslimited   # BlackBoxOptim optimization method for RBF hyperparameters\nrbf_dist_metric = Distances.Euclidean()                 # Distance metric used to create the RBF\nvariable_kernel_width::Bool = true                      # Allow individual kernels and widths for each sample\nvariable_dim_scaling::Bool = true                       # Linearly scale the input dimensions for best fit\ncond_max::Float64 = 1e4                                 # Maximum allowed condition number of RBF matrix A\nmax_rbf_width::Float64 = 1000.0                         # Maximum RBF width factor\nmin_rbf_width::Float64 = 1e-4                           # Minimum RBF width factor\nmax_scale::Float64 = 10.0                               # Maximum linear input dimension scaling factor\nmin_scale::Float64 = 1e-4                               # Minimum linear input dimension scaling factor\nnum_interpolants::Int = 20                              # Number of interpolants in ensemble\nsmooth = :single                                        # Apply smoothing factor, useful for functions with noise\n                                                        # false turned off, :single one factor for all points,\n                                                        # :variable individual factor for each point, \n                                                        # :single_user user supplied value\nmax_smooth::Float64 = 1.0                               # Maximum smoothing factor \nsmooth_user::Float64 = 0.0                              # User supplied smoothing factor, only applied if smooth = :single_user\niterations::Int64 = 10                                  # Number of infill iterations to be run\nnum_infill_points::Int64 = 1                            # Number of infill points per iteration\nparallel_surrogate::Bool = true                         # Create each surrogate in the ensemble in parallel\ninfill_funcs::Array{Symbol,1} = [:median,:std]          # Infill criteria, cycled through \ninfill_iterations::Int64 = 25_000                       # Iterations to add infill points to the design space","category":"page"}]
}
